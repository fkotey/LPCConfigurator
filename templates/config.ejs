; Configuration file for <%- board.caption %> (firmware version <%- util.getFirmwareString() %>)
; executed by the firmware on start-up
;
; generated by RepRapFirmware Configuration Tool v2 on <%- (new Date()).toString() %>

; General preferences
G90 ; Send absolute coordinates...
M83 ; ...but relative extruder moves
<%	if (template.geometry.type == "delta") { -%>
M665 R<%- template.geometry.delta_radius %> L<%- template.geometry.rod_length %> B<%- template.geometry.print_radius %> H<%- template.geometry.homed_height %> ; Set delta radius, diagonal rod length, printable radius and homed height
M666 X0 Y0 Z0 ; Put your endstop adjustments here, or let auto calibration find them
<%	} else if (template.geometry.type.startsWith("core")) {
		let sParam = 1;
		if (template.geometry.type == "corexz") { sParam = 2; }
		if (template.geometry.type == "coreyz") { sParam = 3; } %>
M667 S<%- sParam %> ; Select CoreXY mode
<% } -%>

; Network
<%	if (template.network.enabled && board.hasEthernet == true) { -%>
M550 P"<%- template.network.name %>" ; Set machine name
<%		if (template.network.password != "") { -%>
M551 P"<%- template.network.password %>" ; Set password
<%		}
		if (template.network.hasOwnProperty("mac_address") && template.network.mac_address != "") { -%>
M540 P<%- template.network.mac_address %> ; Set custom MAC address
<%		}
		
		if (template.network.dhcp) { -%>
M552 P0.0.0.0 ; Acquire IP address via DHCP
<%		} else { -%>
M552 P<%- template.network.ip %> ; Set IP address 
M553 P<%- template.network.netmask %> ; Set netmask
M554 P<%- template.network.gateway %> ; Set gateway
<%		} -%>
M552 S1 ; Enable network
M586 P0 S<%- template.network.protocols.http ? "1" : "0" -%> ; <%- template.network.protocols.http ? "Enable" : "Disable" -%> HTTP
M586 P1 S<%- template.network.protocols.ftp ? "1" : "0" -%> ; <%- template.network.protocols.ftp ? "Enable" : "Disable" -%> FTP
M586 P2 S<%- template.network.protocols.telnet ? "1" : "0" -%> ; <%- template.network.protocols.telnet ? "Enable" : "Disable" -%> Telnet
<%	} else { -%>
M552 S0 ; Disable network
<%	} -%>

; Drives
<%	let xDrives, yDrives, zDrives, eDrives;
	let drivesRemapped = false;
	template.drives.forEach(function(drive, i) {
-%>
M569 P<%- drive.driver %> S<%- drive.direction %> <%- (drive.stepperDriver != null)?"T"+drive.stepperDriverTimings:"" %> ; Physical drive <%- drive.driver %> goes <%- (drive.direction == 0) ? "backwards" : "forwards" %> using <%- (drive.stepperDriver != null)?drive.stepperDriver:"default" %> driver timings
<%		switch (i) {
			case 0: // X axis
				if (xDrives == undefined) {
					xDrives = drive.driver;
				} else {
					xDrives += ":" + drive.driver;
				}
				break;

			case 1: // Y axis
				if (zDrives == undefined) {
					yDrives = drive.driver;
				} else {
					yDrives += ":" + drive.driver;
				}
				break;

			case 2: // Z axis
				if (zDrives == undefined) {
					zDrives = drive.driver;
				} else {
					zDrives += ":" + drive.driver;
				}
				break;

			default: // E drives
				if (eDrives == undefined) {
					eDrives = drive.driver;
				} else {
					eDrives += ":" + drive.driver;
				}
				break;
		}
		drivesRemapped |= (drive.driver != i);
	});

	let parameters = "";
	if (drivesRemapped) {
		if (xDrives != undefined) {
			parameters += " X" + xDrives;
		}
		if (yDrives != undefined) {
			parameters += " Y" + yDrives;
		}
		if (zDrives != undefined) {
			parameters += " Z" + zDrives;
		}
		if (eDrives != undefined) {
			parameters += " E" + eDrives;
		} -%>
M584<%- parameters %> ; Apply custom drive mapping
<%	}

	if (board.microstepping) {
		parameters = "";
		template.drives.forEach(function(drive, i) {
			if (!drive.microstepping_interpolation) {
				switch(i) {
					case 0:
						parameters += " X" + drive.microstepping;
						break;
					case 1:
						parameters += " Y" + drive.microstepping;
						break;
					case 2:
						parameters += " Z" + drive.microstepping;
						break;
					default:
						if (parameters.indexOf("E") == -1) {
							parameters += " E" + drive.microstepping
						} else {
							parameters += ":" + drive.microstepping;
						}
						break;
				}
			}
		});
		if (parameters != "") { -%>
M350<%- parameters %> I0 ; Configure microstepping without interpolation
<%		}

		parameters = "";
		template.drives.forEach(function(drive, i) {
			if (drive.microstepping_interpolation) {
				switch(i) {
					case 0:
						parameters += " X" + drive.microstepping;
						break;
					case 1:
						parameters += " Y" + drive.microstepping;
						break;
					case 2:
						parameters += " Z" + drive.microstepping;
						break;
					default:
						if (parameters.indexOf("E") == -1) {
							parameters += " E" + drive.microstepping;
						} else {
							parameters += ":" + drive.microstepping;
						}
						break;
				}
			}
		});
		if (parameters != "") { -%>
M350<%- parameters %> I1 ; Configure microstepping with interpolation
<%		}
	} -%>
M92 <%- util.makeDriveString("steps_per_mm", 1) %> ; Set steps per mm
M566 <%- util.makeDriveString("instant_dv", 60) %> ; Set maximum instantaneous speed changes (mm/min)
M203 <%- util.makeDriveString("max_speed", 60) %> ; Set maximum speeds (mm/min)
M201 <%- util.makeDriveString("acceleration", 1) %> ; Set accelerations (mm/s^2)
<%	if (template.idle.used) { -%>
M906 <%- util.makeDriveString("current", 1) %> I<%- template.idle.factor %> ; Set motor currents (mA) and motor idle factor in per cent
M84 S<%- template.idle.timeout %> ; Set idle timeout
<%	} else { -%>
M906 <%- util.makeDriveString("current", 1) %> ; Set motor currents (mA)
M84 S0 ; Disable motor idle current reduction
<%	} -%>

; Axis Limits
<%	if (template.geometry.type == "delta") { -%>
M208 Z<%- template.geometry.z_min %> S1 ; Set minimum Z
<%	} else { -%>
M208 X<%- template.geometry.mins[0] %> Y<%- template.geometry.mins[1] %> Z<%- template.geometry.mins[2] %> S1 ; Set axis minima
M208 X<%- template.geometry.maxes[0] %> Y<%- template.geometry.maxes[1] %> Z<%- template.geometry.maxes[2] %> S0 ; Set axis maxima
<%	} -%>

; Endstops
<%	


	let axisNames = ["X", "Y", "Z"];
	let probeTypes = ["active low", "active high", "z-probe"];
	for(var i=0; i<3; i++)
	{
		if(template.drives[i].endstop_type ==0 )
		{
			//None
-%>
M574 <%- axisNames[i] %>0 ; // No <%- axisNames[i] %> Endstop
<%			
		}
		else if(template.drives[i].endstop_type!=3) //not Z-Probe
 		{
	
			let loc = template.drives[i].endstop_location; //min or max 
			let lpc_pin = template.drives[i].endstop_pin; //LPC Pin		
			//let activeHigh = (template.drives[i].endstop_type == 1);
			let pinName = util.lookupNameForPin(template.drives[i].endstop_pin, board.lpc.endstops);
		
			//(RRF Config tool values) endstop_type: 0=None, 1=Normally Closed, 2=Normally Open, 3=ZProbe is used.
			//Map to M574 S format:
//			Snnn Endstop type: 0 = active low endstop input, 1 = active high endstop input, 2 = Z probe, 3 = motor load detection

			let endstopType = 0;
			//get the endstop type from configtool
			switch(template.drives[i].endstop_type){
				case 1: //Normally Closed (active high)
					endstopType = 1;
					break;
				case 2: //Normally Open (active low)
					endstopType = 0
					break;
				case 3: //ZProbe
					endstopType = 2
					break;
			}


-%>
M574 <%- axisNames[i] %><%- loc %> S<%- endstopType %> P"<%- pinName %>" ; Set <%- probeTypes[endstopType] %> endstop at axis <%- (loc==1)?"minimum":"maximum" %> attached to <%- pinName %> (P<%- lpc_pin %>) 
<%	
		}
	}; 
-%>

; Z-Probe
<%	
	let zProbeType = (template.geometry.type == "delta") ? 4 : 0;
	if (template.probe.type == "noprobe") { -%>
M558 P0 H<%- template.z_dive_height %> F<%- template.probe.speed * 60 %> T<%- template.travel_speed * 60 %> ; Disable Z probe but set dive height, probe speed and travel speed
<%	} 
	else 
	{

		let lpcProbePin = template.probe.probe_pin;

		if (template.probe.type == "unmodulated") { zProbeType = 1; }
		if (template.probe.type == "modulated") { zProbeType = 2; }
		if (template.probe.type == "ultrasonic") { zProbeType = 3; }
		if (template.probe.type == "switch") { zProbeType = (template.geometry.type == "delta") ? 4 : 5; }
		if (template.probe.type == "effector") { zProbeType = "5 R" + template.probe.recovery_time; }
		if (template.probe.type == "bltouch") { zProbeType = (template.firmware < 1.21) ? 5 : 9; } -%>
M558 C"<%- util.lookupNameForPin(lpcProbePin, board.lpc.endstops) %>" P<%- zProbeType %> H<%- template.z_dive_height %> F<%- template.probe.speed * 60 %> T<%- template.travel_speed * 60 %> ; Set Z probe type to <%- template.probe.type %><% if (template.firmware < 1.20) { -%>, the axes for which it is used<% } -%> and the dive height + speeds. Probe attached to <%- util.lookupNameForPin(lpcProbePin, board.lpc.endstops) %> (P<%- lpcProbePin %>)  
<%		if (template.geometry.low_dive_height) { -%>
M558 H30 ;*** Remove this line after delta calibration has been done and new delta parameters have been saved
<%		} -%>
G31 P<%- template.probe.trigger_value %> X<%- template.probe.x_offset %> Y<%- template.probe.y_offset %> Z<%- template.probe.trigger_height %> ; Set Z probe trigger value, offset and trigger height
<%	}
	if (template.orthogonal.compensation) { -%>
M556 S<%- template.orthogonal.height %> X<%- template.orthogonal.deviations[0] %> Y<%- template.orthogonal.deviations[1] %> Z<%- template.orthogonal.deviations[2] %> ; Set orthogonal axis compensation parameters
<%	}
	if (template.geometry.type == "delta") {-%>
M557 R<%- template.mesh.radius %> S<%- template.mesh.spacing %> ; Define mesh grid
<%	} else { -%>
M557 X<%- template.mesh.x_min %>:<%- template.mesh.x_max %> Y<%- template.mesh.y_min %>:<%- template.mesh.y_max %> S<%- template.mesh.spacing %> ; Define mesh grid
<%	} -%>

; Heaters
<%	
	// FIXME: Adjust the block below if Steinhart-Hart parameters are supposed to be used!
	template.heaters.forEach(function(heater, i) 
	{
		if (heater != null) 
		{
			if(i==0 && !template.bed.present)
			{
				//no heat bed!
			} 
			else 
			{
				if(template.heaters[i].heater != -1 && template.heaters[i].heater != "NoPin" && template.heaters[i].heater != "")
				{
-%>
<%# TODO:: Only handles Thermistors currently %>
; Heater <%- i %>
M308 S<%- i -%> P"<%- util.lookupNameForPin(heater.channel, board.lpc.thermistors) %>" Y"thermistor"  T<%- heater.thermistor %> B<%- heater.beta + ((heater.c == 0) ? 0 : " C" + heater.c.toExponential(6)) %> R<%- heater.series %> ; Set thermistor + ADC parameters for heater <%- i %>
M950 H<%- i -%> C"<%- util.lookupNameForPin(heater.heater, board.lpc.mosfets) -%>" T<%- i %> Q<%- (i==0)?10:250 %> ; Heater <%- i %> attached to pin <%- util.lookupNameForPin(heater.heater, board.lpc.mosfets) %> (P<%- heater.heater %>) with PWM Frequency at <%- (i==0)?10:250 %>Hz
M143 H<%- i %> S<%- heater.temp_limit %> ; Set temperature limit for heater <%- i %> to <%- heater.temp_limit %>C
<%
					if (i == 0) 
					{ 
						//set heated bed to PID or Bang Bang
						if (template.bed.use_pid) 
						{ 
-%>
M307 H0 B0 S<%- (template.heaters[0].scale_factor / 100).toFixed(2) %> ; Disable bang-bang mode for the bed heater and set PWM limit
<%						} 
						else 
						{ 
-%>
M307 H0 B1 S<%- (template.heaters[0].scale_factor / 100).toFixed(2) %>; Enable bang-bang mode for the bed heater and set PWM limit
<%						}
					}
				} 
			}			
		}//end if heater!=null
	}); 
-%>

; Fans
<%	template.fans.forEach(function(fan, fanNumber) {
		const thermostaticOptions = (fan.thermostatic) ? "H" + fan.heaters.join(":") + " T" + fan.trigger_temperature : "H-1"; -%>
M950 F<%- fanNumber -%> C"<%- util.lookupNameForPin(fan.fanPin, board.lpc.mosfets) -%>" Q250 %> ; Fan <%- fanNumber %> attached to pin <%- util.lookupNameForPin(fan.fanPin, board.lpc.mosfets) %> (P<%- fan.fanPin %>) with PWM Frequency at 250Hz
M106 P<%- fanNumber %> S<%- fan.value / 100 %> I<%- fan.inverted ? 1 : 0 %> F<%- fan.frequency %> <%- thermostaticOptions %> ; Set fan <%- fanNumber %> value, PWM signal inversion and frequency. Thermostatic control is turned <%- fan.thermostatic ? "on" : "off" %>

<%	}); -%>
<%
let servoPins = []; 
	
	//set the pins defined on the board
	for(var i=0; i< board.lpc.servoPins.length; i++){
		servoPins.push(board.lpc.servoPins[i].value);
	}
	
	//define servo pin manually entered for BLTouch
	if( template.lpc.manualServoPin != "NoPin" && template.lpc.manualServoPin != "" ){
		servoPins.push( template.lpc.manualServoPin );
	}

	if(servoPins.length != 0) 
	{ 
-%>
; GPIO Port settings (for servos etc)
<% 		servoPins.forEach(function(servoPin, servoNumber) 
		{ 
-%>
M950 S<%- servoNumber -%> C"<%- util.lookupNameForPin(servoPin, board.lpc.servoPins) -%>" Q50 %> ;
<%		}); 
	} 

	if(template.lpc.lcdEnabled) { 
-%>
; LCD
M918 P1 F1000000 ; Enable LCD with SPI Frequency of 1MHz
<% } -%>

; Tools
<%	let toolParams;
	template.tools.forEach(function(tool) {
		toolParams = '';
		if (tool.name != '') {
			toolParams += ` S"${tool.name}"`;
		}
		if (tool.extruders.length > 0) {
			toolParams += ` D${tool.extruders.join(':')}`;
		}
		if (tool.heaters.length > 0) {
			toolParams += ` H${tool.heaters.join(':')}`;
		}
-%>
M563 P<%- tool.number + toolParams %> ; Define tool <%- tool.number %>
G10 P<%- tool.number %> X<%- tool.x_offset %> Y<%- tool.y_offset %> Z<%- tool.z_offset %> ; Set tool <%- tool.number %> axis offsets
G10 P<%- tool.number %> R0 S0 ; Set initial tool <%- tool.number %> active and standby temperatures to 0C
<%		if (tool.extruders.length > 1) { -%>
M568 P<%- tool.number %> S1 ; Enable mixing for tool <%- tool.number %>
M567 P<%- tool.number %> E<%- tool.mix_ratio.join(":") %> ; Set mixing ratios for tool <%- tool.number %>
<%		}
	});

	if (template.custom_settings.trim() != "") { -%>

; Custom settings
<%- template.custom_settings %>
<%	} else { -%>

; Custom settings are not configured
<%	}
	if (template.nvram || (template.generate_t_code && template.tools.length > 0)) { -%>

; Miscellaneous
<%		if (template.nvram) { -%>
M501 ; Load saved parameters from non-volatile memory
<%		}
		if (template.generate_t_code && template.tools.length > 0) { -%>
T<%- template.tools[0].number %> ; Select first tool
<%		}
	} -%>
